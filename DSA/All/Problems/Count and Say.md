

[LeetCode #38: Count and Say](https://leetcode.com/problems/count-and-say/)

## Description

The "Count and Say" sequence is a sequence of digit strings defined by the following rules:

- The sequence starts with the string "1".
- Each subsequent string is generated by describing the previous string's digits.

For example, the sequence goes as follows:

1. `1` is read off as "one 1" or `11`.
2. `11` is read off as "two 1s" or `21`.
3. `21` is read off as "one 2, then one 1" or `1211`.
4. `1211` is read off as "one 1, one 2, then two 1s" or `111221`.
5. And so on...

### Input

- An integer `n` (1 ≤ n ≤ 30), which represents the n-th term of the sequence.

### Output

- The n-th term of the "Count and Say" sequence as a string.

## Examples

### Example 1

**Input:**
```plaintext
n = 1
```
**Output:**
```plaintext
"1"
```

### Example 2

**Input:**
```plaintext
n = 4
```
**Output:**
```plaintext
"1211"
```

### Example 3

**Input:**
```plaintext
n = 5
```
**Output:**
```plaintext
"111221"
```

## Constraints

- `1 ≤ n ≤ 30`

## Solutions

### Approach 1: Iterative Method

In this approach, we build the sequence iteratively from the first term up to the n-th term. Each term is generated by reading the previous term and counting the occurrences of each digit.

```python
def countAndSay(n: int) -> str:
    # Starting term of the sequence
    result = "1"
    
    for _ in range(1, n):
        current = ""
        count = 1
        
        # Iterate over the result to count occurrences
        for j in range(1, len(result)):
            if result[j] == result[j - 1]:
                count += 1  # Increment count if the same digit
            else:
                # Append the count and the digit
                current += str(count) + result[j - 1]
                count = 1  # Reset count for new digit
        
        # Append the last counted digit
        current += str(count) + result[-1]
        result = current  # Update result to the current term
    
    return result
```


```python

def count_and_say(n:int, text:List[str] = ['1'])->str:
    if(n == 1):
        return ''.join(text)

    while(n != 1):
        text_len = len(text)
        new_text:List[str] = []
        prev_char_start_index = 0

        if(text_len == 1 and text[0] == '1'):
            text = ['1','1']
            n = n-1
            continue
        for current_index in range(1,text_len):
            prev_index = current_index - 1
            next_index = current_index + 1
            if(text[current_index] != text[prev_index] ):
                prev_char = text[prev_index]
                prev_char_repeated_count = current_index - prev_char_start_index
                new_text.append(str(prev_char_repeated_count))
                new_text.append(prev_char)
                prev_char_start_index = current_index

            if(next_index == text_len):
                prev_char = text[current_index]
                prev_char_repeated_count = next_index - prev_char_start_index
                new_text.append(str(prev_char_repeated_count))
                new_text.append(prev_char)
                prev_char_start_index = current_index

        text = new_text
        n = n-1

    return ''.join(text)


```

### Time Complexity
- **O(2^n)** due to the string concatenation in each iteration.

### Space Complexity
- **O(1)** for the variables used, but the output string grows based on the term number.

---

### Approach 2: Recursive Method

A recursive approach can also be applied where the function calls itself to build the sequence. This method may not be as efficient due to its call stack overhead.

```python
def countAndSay(n: int) -> str:
    # Base case
    if n == 1:
        return "1"

    # Recursive case
    previous_term = countAndSay(n - 1)
    current = ""
    count = 1

    # Iterate over the previous term
    for j in range(1, len(previous_term)):
        if previous_term[j] == previous_term[j - 1]:
            count += 1
        else:
            current += str(count) + previous_term[j - 1]
            count = 1

    # Append the last counted digit
    current += str(count) + previous_term[-1]
    
    return current
```



```python


def count_and_say2(n:int)->str:

    if(n<1):
        return 'not test case'

    def encry(n, text:List[str])->str:
        if(n == 0):
            return ''.join(text)
        next_text = []
        text_len = len(text)
        char_index = 0
        for i in range(text_len-1):
            cur_char = text[i]
            if(cur_char != text[i+1]):
                repeat = i - char_index  + 1
                next_text.append(str(repeat))
                next_text.append(cur_char)
                char_index = i+1
        else:
            repeat = (text_len -1) - char_index + 1
            next_text.append(str(repeat))
            next_text.append(text[text_len-1])

        return encry(n-1, next_text)

    return encry(n-1,['1'])



```

### Time Complexity
- **O(2^n)** due to the recursive calls and string concatenation.

### Space Complexity
- **O(n)** due to the recursion stack.

---

## Summary of Approaches

| Approach        | Time Complexity | Space Complexity |
|-----------------|-----------------|------------------|
| **Iterative**   | O(2^n)          | O(1)             |
| **Recursive**   | O(2^n)          | O(n)             |

---

## Test Cases

```python
def test_count_and_say(func):
    test_cases = [
        {
            "input": 1,
            "expected": "1",
        },
        {
            "input": 2,
            "expected": "11",
        },
        {
            "input": 3,
            "expected": "21",
        },
        {
            "input": 4,
            "expected": "1211",
        },
        {
            "input": 5,
            "expected": "111221",
        },
        {
            "input": 6,
            "expected": "312211",
        },
        {
            "input": 7,
            "expected": "13112221",
        },
        {
            "input": 8,
            "expected": "1113213211",
        },
        {
            "input": 9,
            "expected": "31131211131221",
        },
    ]

    for i, test_case in enumerate(test_cases, 1):
        result = func(test_case["input"])
        assert result == test_case["expected"], f"Test case {i} failed: expected {test_case['expected']}, got {result}"

    print("All test cases passed!")

# Example usage
test_count_and_say(countAndSay)
```

---

This structured format provides a clear and concise overview of the **"Count and Say"** problem, including problem description, examples, solution approaches, complexities, and test cases. If you have further requests or need additional information, feel free to ask!


